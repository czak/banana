package pl.czak.banana.processor;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.RoundEnvironment;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import javax.tools.Diagnostic;
import javax.tools.JavaFileObject;

import pl.czak.banana.annotation.BindView;

public class BananaProcessor extends AbstractProcessor {
    private Messager messager;
    private Filer filer;

    @Override
    public synchronized void init(ProcessingEnvironment processingEnv) {
        super.init(processingEnv);

        messager = processingEnv.getMessager();
        filer = processingEnv.getFiler();
    }

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        Map<TypeElement, List<Element>> bindingMap = new HashMap<>();

        // Gather fields by class
        for (Element e : roundEnv.getElementsAnnotatedWith(BindView.class)) {
            TypeElement typeElement = (TypeElement) e.getEnclosingElement();

            bindingMap.merge(typeElement, new ArrayList<>(Collections.singletonList(e)), (o, n) -> {
                o.addAll(n);
                return o;
            });
        }

        // Process per-file
        for (Map.Entry<TypeElement, List<Element>> entry : bindingMap.entrySet()) {
            TypeElement typeElement = entry.getKey();
            List<Element> elements = entry.getValue();

            try {
                String className = typeElement.getQualifiedName().toString() + "ViewBinder";
                JavaFileObject file = filer.createSourceFile(className);

                try (PrintWriter out = new PrintWriter(file.openWriter())) {
                    // FIXME: Super nasty hardcoded source
                    out.println("// Generated by banana. Do not edit.");
                    out.println("package pl.czak.bananasample;");
                    out.println();
                    out.println("import android.widget.TextView;");
                    out.println();
                    out.println("import pl.czak.banana.ViewBinder;");
                    out.println();
                    out.println("public class MainActivityViewBinder implements ViewBinder<MainActivity> {");
                    out.println("    public void bind(MainActivity activity) {");
                    out.println("        activity.label = (TextView) activity.findViewById(R.id.label);");
                    out.println("    }");
                    out.println("}");

                }
            } catch (IOException e) {
                messager.printMessage(Diagnostic.Kind.ERROR, e.getMessage());
            }
        }

        return true;
    }

    @Override
    public Set<String> getSupportedAnnotationTypes() {
        return Collections.singleton(BindView.class.getCanonicalName());
    }

    @Override
    public SourceVersion getSupportedSourceVersion() {
        return SourceVersion.latestSupported();
    }
}
